import React, { useRef, useEffect, useReducer, useContext, useState, useImperativeHandle, useLayoutEffect, useCallback } from 'react';
import PropTypes from 'prop-types';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * Returns a ref that gets updated with the latest value on every render
 */
var useUpdatingRef = function (value) {
    var ref = useRef(value);
    ref.current = value;
    return ref;
};
/**
 * Returns a ref telling whether the calling component has been mounted or not.
 * Is false for the first render and unmount step.
 */
var useIsMountedRef = function () {
    var isMountedRef = useRef(false);
    useEffect(function () {
        isMountedRef.current = true;
        return function () {
            isMountedRef.current = false;
        };
    }, [isMountedRef]);
    return isMountedRef;
};
/**
 * Returns a function to force-update a component
 */
var useForceUpdate = function () {
    var _a = useReducer(function (x) { return x + 1; }, 0), forceUpdate = _a[1];
    return forceUpdate;
};
/**
 * Triggers a cancel callback when the Escape key is pressed with a mode active
 *
 * @param isActive The mode is active
 * @param cancel Callback to cancel out of the mode
 */
var useCancelModeOnEscapeKey = function (isActive, cancel) {
    useEffect(function () {
        if (!isActive)
            return undefined;
        var doCancel = function (event) {
            if (event.key === 'Escape') {
                event.preventDefault();
                cancel();
            }
        };
        window.addEventListener('keydown', doCancel);
        return function () {
            window.removeEventListener('keydown', doCancel);
        };
    }, [isActive, cancel]);
};

// eslint-disable-next-line no-shadow
var EventType;
(function (EventType) {
    EventType["MountedOrUnmounted"] = "MountedOrUnmounted";
    EventType["MouseEvent"] = "MouseEvent";
    EventType["ChildRectChanged"] = "ChildRectChanged";
    EventType["ChildFocus"] = "ChildFocus";
    EventType["ChildToggleSelection"] = "ChildToggleSelection";
})(EventType || (EventType = {}));
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.listeners = {};
    }
    EventEmitter.prototype.addListener = function (eventType, fn) {
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(fn);
        return this;
    };
    EventEmitter.prototype.removeListener = function (eventType, fn) {
        var matchingListeners = this.listeners[eventType];
        if (!matchingListeners) {
            return this;
        }
        for (var i = matchingListeners.length; i > 0; i -= 1) {
            if (matchingListeners[i] === fn) {
                matchingListeners.splice(i, 1);
                break;
            }
        }
        return this;
    };
    EventEmitter.prototype.overwriteAllListenersOfType = function (eventType, fn) {
        delete this.listeners[eventType];
        return this.addListener(eventType, fn);
    };
    EventEmitter.prototype.emit = function (eventType) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var matchingListeners = this.listeners[eventType];
        if (!matchingListeners) {
            return;
        }
        matchingListeners.forEach(function (f) {
            f.current.apply(f, args);
        });
    };
    return EventEmitter;
}());
var useNewEventEmitter = function () {
    var emitterRef = useRef(new EventEmitter());
    return emitterRef.current;
};
var useAdditionalListener = function (emitter, eventType, listener) {
    var listenerRef = useUpdatingRef(listener);
    emitter
        .removeListener(eventType, listenerRef)
        .addListener(eventType, listenerRef);
};
var EventEmitterContext = React.createContext(undefined);
var EventEmitterProvider = EventEmitterContext.Provider;
var useEventEmitterContext = function () {
    var emitter = useContext(EventEmitterContext);
    if (emitter === undefined) {
        throw new Error('useEventEmitterContext must be used within a EventEmitterProvider');
    }
    return emitter;
};

var CoordinateGetterRefContext = React.createContext(undefined);
var DimensionsContext = React.createContext(undefined);
var dimensionsProviderPropTypes = {
    value: PropTypes.shape({
        vectorWidth: PropTypes.number.isRequired,
        vectorHeight: PropTypes.number.isRequired,
        vectorPaddingTop: PropTypes.number.isRequired,
        vectorPaddingRight: PropTypes.number.isRequired,
        vectorPaddingBottom: PropTypes.number.isRequired,
        vectorPaddingLeft: PropTypes.number.isRequired,
        scale: PropTypes.number.isRequired,
    }).isRequired,
    children: PropTypes.node.isRequired,
};
var DimensionsProvider = function (_a) {
    var children = _a.children, propDims = _a.value;
    // Essentially memoizing the dimensions so passing an object doesn't
    // trigger re-renders on every render of the parent
    // See: https://reactjs.org/docs/context.html#caveats
    var _b = useState(propDims), dimensions = _b[0], setDimensions = _b[1];
    var isMountedRef = useIsMountedRef();
    useEffect(function () {
        // Skip the mount/unmount step because the state
        // has already been initialized with the propDims
        if (!isMountedRef.current) {
            return;
        }
        setDimensions(propDims);
    }, [
        propDims.scale,
        propDims.vectorWidth,
        propDims.vectorHeight,
        propDims.vectorPaddingTop,
        propDims.vectorPaddingRight,
        propDims.vectorPaddingBottom,
        propDims.vectorPaddingLeft,
    ]);
    return (React.createElement(DimensionsContext.Provider, { value: dimensions }, children));
};
DimensionsProvider.propTypes = dimensionsProviderPropTypes;
var CoordinateGetterRefProvider = CoordinateGetterRefContext.Provider;
/**
 * Access the root context values
 */
var useRootContext = function () {
    var coordinateGetterRef = useContext(CoordinateGetterRefContext);
    if (coordinateGetterRef === undefined) {
        throw new Error('useRootContext must be used within a CoordinateGetterRefProvider');
    }
    var dimensions = useContext(DimensionsContext);
    if (dimensions === undefined) {
        throw new Error('useRootContext must be used within a DimensionsProvider');
    }
    return {
        eventEmitter: useEventEmitterContext(),
        coordinateGetterRef: coordinateGetterRef,
        dimensions: dimensions,
    };
};

var useMouseEventForwarding = function (eventEmitter) {
    useEffect(function () {
        var onMouseEvent = function (event) {
            eventEmitter.emit(EventType.MouseEvent, event);
        };
        window.addEventListener('mouseup', onMouseEvent);
        window.addEventListener('mousemove', onMouseEvent);
        return function () {
            window.removeEventListener('mouseup', onMouseEvent);
            window.removeEventListener('mousemove', onMouseEvent);
        };
    }, [eventEmitter]);
};
var useChildAddDeleteHandler = function (focusOnAdd, focusOnDelete) {
    var justAddedShapeActionRefsRef = useRef([]);
    var wrappedShapeActionRefsRef = useRef([]);
    var lastDeletedRectRef = useRef(null);
    useLayoutEffect(function () {
        if (justAddedShapeActionRefsRef.current.length > 0 && focusOnAdd) {
            // Focus on shapes added since the last update
            justAddedShapeActionRefsRef.current.slice(-1)[0].current.forceFocus();
        }
        else if (lastDeletedRectRef.current && focusOnDelete) {
            // If something was deleted since the last update, focus on the
            // next closest shape by center coordinates
            var getShapeCenter_1 = function (shape) { return ({
                x: shape.x + shape.width / 2,
                y: shape.y + shape.height / 2,
            }); };
            var deletedShapeCenter_1 = getShapeCenter_1(lastDeletedRectRef.current);
            var closestDistance_1 = Math.pow(2, 53) - 1;
            var closestShapeActions_1 = null;
            wrappedShapeActionRefsRef.current.forEach(function (shapeActionRef) {
                var shapeCenter = getShapeCenter_1(shapeActionRef.current.props);
                var distance = Math.pow((deletedShapeCenter_1.x - shapeCenter.x), 2) +
                    Math.pow((deletedShapeCenter_1.y - shapeCenter.y), 2);
                if (distance < closestDistance_1) {
                    closestDistance_1 = distance;
                    closestShapeActions_1 = shapeActionRef.current;
                }
            });
            if (closestShapeActions_1 !== null) {
                closestShapeActions_1.forceFocus();
            }
        }
        justAddedShapeActionRefsRef.current = [];
        lastDeletedRectRef.current = null;
    });
    var editorMountedRef = useIsMountedRef();
    var onShapeMountedOrUnmounted = function (shapeActionsRef, didMount) {
        if (didMount) {
            // Only monitor shapes added after the initial editor render
            if (editorMountedRef.current) {
                justAddedShapeActionRefsRef.current = __spreadArrays(justAddedShapeActionRefsRef.current, [
                    shapeActionsRef,
                ]);
            }
            wrappedShapeActionRefsRef.current = __spreadArrays(wrappedShapeActionRefsRef.current, [
                shapeActionsRef,
            ]);
        }
        else {
            var _a = shapeActionsRef.current.props, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
            lastDeletedRectRef.current = { x: x, y: y, width: width, height: height };
            wrappedShapeActionRefsRef.current = wrappedShapeActionRefsRef.current.filter(function (s) { return s !== shapeActionsRef; });
        }
    };
    return onShapeMountedOrUnmounted;
};
var propTypes = {
    children: PropTypes.node.isRequired,
    focusOnAdd: PropTypes.bool,
    focusOnDelete: PropTypes.bool,
    padding: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.shape({
            top: PropTypes.oneOfType([
                PropTypes.number.isRequired,
                PropTypes.oneOf([undefined]),
            ]).isRequired,
            right: PropTypes.oneOfType([
                PropTypes.number.isRequired,
                PropTypes.oneOf([undefined]),
            ]).isRequired,
            bottom: PropTypes.oneOfType([
                PropTypes.number.isRequired,
                PropTypes.oneOf([undefined]),
            ]).isRequired,
            left: PropTypes.oneOfType([
                PropTypes.number.isRequired,
                PropTypes.oneOf([undefined]),
            ]).isRequired,
        }),
    ]),
    scale: PropTypes.number,
    style: PropTypes.shape({}),
    vectorHeight: PropTypes.number.isRequired,
    vectorWidth: PropTypes.number.isRequired,
};
var ShapeEditor = React.forwardRef(function (_a, forwardedRef) {
    var children = _a.children, _b = _a.focusOnAdd, focusOnAdd = _b === void 0 ? true : _b, _c = _a.focusOnDelete, focusOnDelete = _c === void 0 ? true : _c, _d = _a.scale, scale = _d === void 0 ? 1 : _d, _e = _a.style, style = _e === void 0 ? {} : _e, vectorHeight = _a.vectorHeight, vectorWidth = _a.vectorWidth, _f = _a.padding, padding = _f === void 0 ? 0 : _f, otherProps = __rest(_a, ["children", "focusOnAdd", "focusOnDelete", "scale", "style", "vectorHeight", "vectorWidth", "padding"]);
    var _g = typeof padding === 'number'
        ? {
            top: padding,
            right: padding,
            bottom: padding,
            left: padding,
        }
        : __assign({ top: 0, right: 0, bottom: 0, left: 0 }, padding), paddingTop = _g.top, paddingRight = _g.right, paddingBottom = _g.bottom, paddingLeft = _g.left;
    var svgElRef = useRef(null);
    useImperativeHandle(forwardedRef, function () { return svgElRef.current; });
    var getVectorCoordinatesFromMouseEventRef = useUpdatingRef(function (event, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.x, offsetX = _c === void 0 ? 0 : _c, _d = _b.y, offsetY = _d === void 0 ? 0 : _d;
        if (!svgElRef.current) {
            return { x: 0, y: 0 };
        }
        var _e = svgElRef.current.getBoundingClientRect(), top = _e.top, left = _e.left;
        return {
            x: (event.clientX - left - paddingLeft) / scale - offsetX,
            y: (event.clientY - top - paddingTop) / scale - offsetY,
        };
    });
    var onShapeMountedOrUnmounted = useChildAddDeleteHandler(focusOnAdd, focusOnDelete);
    var eventEmitter = useNewEventEmitter();
    useMouseEventForwarding(eventEmitter);
    useAdditionalListener(eventEmitter, EventType.MountedOrUnmounted, onShapeMountedOrUnmounted);
    var vectorPaddingTop = paddingTop / scale;
    var vectorPaddingRight = paddingRight / scale;
    var vectorPaddingBottom = paddingBottom / scale;
    var vectorPaddingLeft = paddingLeft / scale;
    return (React.createElement("svg", __assign({ className: "rse-plane-container", width: vectorWidth * scale + paddingLeft + paddingRight, height: vectorHeight * scale + paddingTop + paddingBottom, preserveAspectRatio: "xMinYMin", viewBox: [
            -vectorPaddingLeft,
            -vectorPaddingTop,
            vectorWidth + vectorPaddingLeft + vectorPaddingRight,
            vectorHeight + vectorPaddingTop + vectorPaddingBottom,
        ].join(' '), ref: svgElRef, style: __assign({ userSelect: 'none' }, style), 
        // IE11 - prevent all elements from being focusable by default
        focusable: "false" }, otherProps),
        React.createElement(CoordinateGetterRefProvider, { value: getVectorCoordinatesFromMouseEventRef },
            React.createElement(EventEmitterProvider, { value: eventEmitter },
                React.createElement(DimensionsProvider, { value: {
                        vectorWidth: vectorWidth,
                        vectorHeight: vectorHeight,
                        vectorPaddingTop: vectorPaddingTop,
                        vectorPaddingRight: vectorPaddingRight,
                        vectorPaddingBottom: vectorPaddingBottom,
                        vectorPaddingLeft: vectorPaddingLeft,
                        scale: scale,
                    } }, children)))));
});
ShapeEditor.propTypes = propTypes;

/* eslint-disable react/no-unused-prop-types */
var propTypes$1 = {
    active: PropTypes.bool.isRequired,
    nativeActive: PropTypes.bool.isRequired,
    cursor: PropTypes.oneOf([
        'ns-resize',
        'ew-resize',
        'nesw-resize',
        'nwse-resize',
    ]).isRequired,
    isBeingChanged: PropTypes.bool.isRequired,
    isInSelectionGroup: PropTypes.bool.isRequired,
    name: PropTypes.oneOf([
        'w',
        'n',
        's',
        'e',
        'nw',
        'ne',
        'sw',
        'se',
    ]).isRequired,
    onMouseDown: PropTypes.func.isRequired,
    recommendedSize: PropTypes.number.isRequired,
    scale: PropTypes.number.isRequired,
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
};
var DefaultResizeHandleComponent = function (_a) {
    var active = _a.active, cursor = _a.cursor, isInSelectionGroup = _a.isInSelectionGroup, onMouseDown = _a.onMouseDown, recommendedSize = _a.recommendedSize, scale = _a.scale, x = _a.x, y = _a.y;
    return (React.createElement("rect", { fill: active ? 'rgba(229,240,244,1)' : 'rgba(229,240,244,0.3)', height: recommendedSize, stroke: active ? 'rgba(53,33,140,1)' : 'rgba(53,33,140,0.3)', strokeWidth: 1 / scale, style: { cursor: cursor, opacity: isInSelectionGroup ? 0 : 1 }, width: recommendedSize, x: x - recommendedSize / 2, y: y - recommendedSize / 2, 
        // The onMouseDown prop must be passed on or resize will not work
        onMouseDown: onMouseDown }));
};
DefaultResizeHandleComponent.propTypes = propTypes$1;

function getRectFromCornerCoordinates(corner1, corner2) {
    return {
        x: Math.min(corner1.x, corner2.x),
        y: Math.min(corner1.y, corner2.y),
        width: Math.abs(corner1.x - corner2.x),
        height: Math.abs(corner1.y - corner2.y),
    };
}
var getNonIntersectingElements = function (arr1, arr2) {
    var set1 = new Set(arr1);
    var set2 = new Set(arr2);
    return __spreadArrays(arr1.filter(function (x) { return !set2.has(x); }), arr2.filter(function (x) { return !set1.has(x); }));
};
var defaultConstrainMove = function (_a) {
    var x = _a.x, y = _a.y;
    return ({
        x: x,
        y: y,
    });
};
var defaultConstrainResize = function (_a) {
    var movingCorner = _a.movingCorner;
    return movingCorner;
};
var forceFocus = function (element) {
    if (!element)
        return;
    if (typeof element.focus === 'function') {
        element.focus();
    }
    else {
        // IE11 doesn't have the focus method, so we use this hack from
        // https://allyjs.io/tutorials/focusing-in-svg.html#focusing-svg-elements
        try {
            HTMLElement.prototype.focus.apply(element);
        }
        catch (error) {
            // silence the error
        }
    }
};
/**
 * Returns elements underneath the specified x and y coordinates.
 * @param clientX
 * @param clientY
 */
var getElementsFromPoint = function (clientX, clientY) {
    return typeof document.msElementsFromPoint === 'function'
        ? Array.prototype.slice.call(
        // msElementsFromPoint returns null when there are no elements
        // found
        document.msElementsFromPoint(clientX, clientY) || [])
        : document.elementsFromPoint(clientX, clientY);
};

var defaultDragState = {
    isMouseDown: false,
    dragStartCoordinates: { x: 0, y: 0 },
    dragCurrentCoordinates: { x: 0, y: 0 },
    dragInnerOffset: { x: 0, y: 0 },
    dragLock: null,
    isDragToMove: true,
};
var getHandles = function (ResizeHandleComponent, sides, scale, active, nativeActive, isInSelectionGroup, coordinateGetterRef, requestMouseHandler, setDragState, isBeingChanged) {
    var currentWidth = sides.right - sides.left;
    var currentHeight = sides.bottom - sides.top;
    // The corner of the resize box that moves
    var movementPoints = {
        nw: { x: sides.left, y: sides.top },
        sw: { x: sides.left, y: sides.bottom },
        ne: { x: sides.right, y: sides.top },
        se: { x: sides.right, y: sides.bottom },
    };
    // The corner of the resize box that stays static
    var anchorPoints = {
        nw: movementPoints.se,
        sw: movementPoints.ne,
        ne: movementPoints.sw,
        se: movementPoints.nw,
    };
    var RECOMMENDED_CORNER_SIZE = 10;
    var cornerSize = RECOMMENDED_CORNER_SIZE / scale;
    var hasSpaciousVertical = (sides.bottom - sides.top) * scale > RECOMMENDED_CORNER_SIZE * 2;
    var hasSpaciousHorizontal = (sides.right - sides.left) * scale > RECOMMENDED_CORNER_SIZE * 2;
    var handlesInfo = [];
    if (hasSpaciousVertical)
        handlesInfo.push(['w', 'nw', 'ew-resize', 0, currentHeight / 2, 'y']);
    if (hasSpaciousHorizontal)
        handlesInfo.push(['n', 'ne', 'ns-resize', currentWidth / 2, 0, 'x']);
    if (hasSpaciousHorizontal)
        handlesInfo.push([
            's',
            'sw',
            'ns-resize',
            currentWidth / 2,
            currentHeight,
            'x',
        ]);
    if (hasSpaciousVertical)
        handlesInfo.push([
            'e',
            'se',
            'ew-resize',
            currentWidth,
            currentHeight / 2,
            'y',
        ]);
    handlesInfo.push(['nw', 'nw', 'nwse-resize', 0, 0, null], ['ne', 'ne', 'nesw-resize', currentWidth, 0, null], ['sw', 'sw', 'nesw-resize', 0, currentHeight, null], ['se', 'se', 'nwse-resize', currentWidth, currentHeight, null]);
    var handles = handlesInfo.map(function (_a) {
        var handleName = _a[0], movementReferenceCorner = _a[1], cursor = _a[2], x = _a[3], y = _a[4], dragLock = _a[5];
        return (React.createElement(ResizeHandleComponent, { key: handleName, active: active, nativeActive: nativeActive, cursor: cursor, isBeingChanged: isBeingChanged, isInSelectionGroup: isInSelectionGroup, name: handleName, onMouseDown: function (event) {
                // Ignore anything but left clicks
                if (event.buttons !== 1)
                    return;
                event.stopPropagation();
                var _a = coordinateGetterRef.current(event), planeX = _a.x, planeY = _a.y;
                var movingPoint = movementPoints[movementReferenceCorner];
                var anchorPoint = anchorPoints[movementReferenceCorner];
                var nextDragInnerOffset = {
                    x: planeX - movingPoint.x,
                    y: planeY - movingPoint.y,
                };
                requestMouseHandler();
                setDragState({
                    isMouseDown: true,
                    dragStartCoordinates: anchorPoint,
                    dragCurrentCoordinates: movingPoint,
                    dragInnerOffset: nextDragInnerOffset,
                    dragLock: dragLock,
                    isDragToMove: false,
                });
            }, recommendedSize: cornerSize, scale: scale, x: x, y: y }));
    });
    return handles;
};
var useNotifyRoot = function (eventEmitter, height, width, x, y, shapeId, isInternalComponent, shapeActions) {
    // Notify of shape rectangle changes
    useLayoutEffect(function () {
        eventEmitter.emit(EventType.ChildRectChanged, shapeId, isInternalComponent);
    }, [height, width, x, y, shapeId, isInternalComponent, eventEmitter]);
    // Notify of mount/unmount
    var shapeActionsRef = useUpdatingRef(shapeActions);
    useLayoutEffect(function () {
        if (!isInternalComponent) {
            eventEmitter.emit(EventType.MountedOrUnmounted, shapeActionsRef, true);
        }
        return function () {
            if (!isInternalComponent) {
                eventEmitter.emit(EventType.MountedOrUnmounted, shapeActionsRef, false);
            }
        };
    }, [shapeActionsRef, isInternalComponent, eventEmitter]);
};
var getNextRectOfSelectionChild = function (selectionStartRect, selectionEndRect, childRect) {
    var scaleX = selectionStartRect.width !== 0
        ? selectionEndRect.width / selectionStartRect.width
        : 0;
    var scaleY = selectionStartRect.height !== 0
        ? selectionEndRect.height / selectionStartRect.height
        : 0;
    return {
        x: selectionEndRect.x + (childRect.x - selectionStartRect.x) * scaleX,
        y: selectionEndRect.y + (childRect.y - selectionStartRect.y) * scaleY,
        width: scaleX !== 0 ? childRect.width * scaleX : selectionEndRect.width,
        height: scaleY !== 0 ? childRect.height * scaleY : selectionEndRect.height,
    };
};
var createSelectionChildRectConstrainedGetter = function (childRect, constrainMove, constrainResize, vectorHeight, vectorWidth) { return function (selectionStartRect, selectionEndRect) {
    var _a = getNextRectOfSelectionChild(selectionStartRect, selectionEndRect, childRect), adjustedX = _a.x, adjustedY = _a.y, adjustedWidth = _a.width, adjustedHeight = _a.height;
    var _b = constrainMove({
        originalX: childRect.x,
        originalY: childRect.y,
        x: adjustedX,
        y: adjustedY,
        width: adjustedWidth,
        height: adjustedHeight,
        vectorHeight: vectorHeight,
        vectorWidth: vectorWidth,
    }), x = _b.x, y = _b.y;
    var _c = constrainResize({
        originalMovingCorner: {
            x: x + childRect.width,
            y: y + childRect.height,
        },
        startCorner: { x: x, y: y },
        movingCorner: {
            x: x + adjustedWidth,
            y: y + adjustedHeight,
        },
        lockedDimension: null,
        vectorHeight: vectorHeight,
        vectorWidth: vectorWidth,
    }), right = _c.x, bottom = _c.y;
    return { x: x, y: y, width: right - x, height: bottom - y };
}; };
var useShapeActions = function (forwardedRef, props, forceFocusCb, getSelectionChildUpdatedRect, setDragState) {
    var shapeActions = {
        props: props,
        forceFocus: forceFocusCb,
        getSelectionChildUpdatedRect: getSelectionChildUpdatedRect,
        simulateTransform: function (nextRect) {
            if (!nextRect) {
                setDragState(defaultDragState);
                return;
            }
            setDragState(function (lastDragState) { return (__assign(__assign({}, lastDragState), { isMouseDown: true, dragStartCoordinates: { x: nextRect.x, y: nextRect.y }, dragCurrentCoordinates: {
                    x: nextRect.x + nextRect.width,
                    y: nextRect.y + nextRect.height,
                } })); });
        },
    };
    useImperativeHandle(forwardedRef, function () { return shapeActions; }, [
        props,
        forceFocusCb,
        setDragState,
    ]);
    return shapeActions;
};
var useMouseHandlerRef = function (props, constrainMove, constrainResize, coordinateGetterRef, dragCurrentCoordinates, dragInnerOffset, dragLock, dragStartCoordinates, eventEmitter, isDragToMove, isMouseDown, onChange, onIntermediateChange, setDragState, vectorHeight, vectorWidth) {
    var height = props.height, width = props.width, x = props.x, y = props.y;
    var onMouseMove = function (event) {
        if (!isMouseDown)
            return;
        if (isDragToMove) {
            var _a = coordinateGetterRef.current(event, dragInnerOffset), rawX = _a.x, rawY = _a.y;
            var coords_1 = constrainMove({
                originalX: dragCurrentCoordinates.x,
                originalY: dragCurrentCoordinates.y,
                x: rawX,
                y: rawY,
                width: width,
                height: height,
                vectorHeight: vectorHeight,
                vectorWidth: vectorWidth,
            });
            var right_1 = coords_1.x + width;
            var bottom_1 = coords_1.y + height;
            setDragState(function (prevState) { return (__assign(__assign({}, prevState), { dragCurrentCoordinates: coords_1, dragStartCoordinates: { x: right_1, y: bottom_1 } })); });
            onIntermediateChange({
                x: coords_1.x,
                y: coords_1.y,
                width: width,
                height: height,
            });
        }
        else {
            var _b = coordinateGetterRef.current(event, dragInnerOffset), rawX = _b.x, rawY = _b.y;
            var _c = constrainResize({
                originalMovingCorner: dragCurrentCoordinates,
                startCorner: dragStartCoordinates,
                movingCorner: { x: rawX, y: rawY },
                lockedDimension: dragLock,
                vectorHeight: vectorHeight,
                vectorWidth: vectorWidth,
            }), nextX = _c.x, nextY = _c.y;
            var coords_2 = {
                x: dragLock !== 'x' ? nextX : dragCurrentCoordinates.x,
                y: dragLock !== 'y' ? nextY : dragCurrentCoordinates.y,
            };
            setDragState(function (prevState) { return (__assign(__assign({}, prevState), { dragCurrentCoordinates: coords_2 })); });
            onIntermediateChange(getRectFromCornerCoordinates(coords_2, dragStartCoordinates));
        }
    };
    var onMouseUp = function () {
        if (!isMouseDown) {
            return;
        }
        if (isDragToMove) {
            var nextX = dragCurrentCoordinates.x, nextY = dragCurrentCoordinates.y;
            setDragState(defaultDragState);
            if (nextX !== x || nextY !== y) {
                onChange({ x: nextX, y: nextY, width: width, height: height }, props);
            }
        }
        else {
            setDragState(defaultDragState);
            var nextRect = getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates);
            if (nextRect.height !== height ||
                nextRect.width !== width ||
                nextRect.x !== x ||
                nextRect.y !== y) {
                onChange(nextRect, props);
            }
        }
    };
    var mouseHandlerRef = useUpdatingRef(function (event) {
        if (event.type === 'mousemove') {
            onMouseMove(event);
        }
        else if (event.type === 'mouseup') {
            onMouseUp();
        }
    });
    return function () {
        eventEmitter.overwriteAllListenersOfType(EventType.MouseEvent, mouseHandlerRef);
    };
};
var useOnKeyDown = function (props, constrainMove, constrainResize, height, keyboardTransformMultiplier, onChange, onDelete, onKeyDown, vectorHeight, vectorWidth, width, x, y) {
    var keyboardMove = function (dX, dY) {
        var _a = constrainMove({
            originalX: x,
            originalY: y,
            x: x + dX * keyboardTransformMultiplier,
            y: y + dY * keyboardTransformMultiplier,
            width: width,
            height: height,
            vectorHeight: vectorHeight,
            vectorWidth: vectorWidth,
        }), nextX = _a.x, nextY = _a.y;
        onChange({ x: nextX, y: nextY, width: width, height: height }, props);
    };
    var keyboardResize = function (dX, dY) {
        var _a = constrainResize({
            originalMovingCorner: {
                x: x + width,
                y: y + height,
            },
            startCorner: { x: x, y: y },
            movingCorner: {
                x: x + width + dX * keyboardTransformMultiplier,
                y: y + height + dY * keyboardTransformMultiplier,
            },
            lockedDimension: null,
            vectorHeight: vectorHeight,
            vectorWidth: vectorWidth,
        }), nextX = _a.x, nextY = _a.y;
        onChange(getRectFromCornerCoordinates({ x: x, y: y }, { x: nextX, y: nextY }), props);
    };
    return function (event) {
        // User-defined callback
        onKeyDown(event, props);
        // If the user-defined callback called event.preventDefault(),
        // we consider the event handled
        if (event.defaultPrevented)
            return;
        var handled = true;
        var handleKeyboardTransform = function (moveArgs, resizeArgs) {
            return event.shiftKey
                ? keyboardResize.apply(void 0, resizeArgs) : keyboardMove.apply(void 0, moveArgs);
        };
        switch (event.key) {
            case 'Backspace':
            case 'Delete':
                onDelete(event, props);
                break;
            case 'ArrowUp':
                handleKeyboardTransform([0, -1], [0, -1]);
                break;
            case 'ArrowRight':
                handleKeyboardTransform([1, 0], [1, 0]);
                break;
            case 'ArrowDown':
                handleKeyboardTransform([0, 1], [0, 1]);
                break;
            case 'ArrowLeft':
                handleKeyboardTransform([-1, 0], [-1, 0]);
                break;
            default:
                handled = false;
        }
        if (handled) {
            event.preventDefault();
        }
    };
};
function wrapShape(WrappedComponent) {
    var propTypes = {
        active: PropTypes.bool,
        constrainMove: PropTypes.func,
        constrainResize: PropTypes.func,
        disabled: PropTypes.bool,
        height: PropTypes.number.isRequired,
        isInSelectionGroup: PropTypes.bool,
        isInternalComponent: PropTypes.bool,
        keyboardTransformMultiplier: PropTypes.number,
        onBlur: PropTypes.func,
        onChange: PropTypes.func,
        onDelete: PropTypes.func,
        onFocus: PropTypes.func,
        onKeyDown: PropTypes.func,
        onIntermediateChange: PropTypes.func,
        ResizeHandleComponent: PropTypes.func,
        shapeId: PropTypes.string.isRequired,
        width: PropTypes.number.isRequired,
        wrapperProps: PropTypes.shape({}),
        x: PropTypes.number.isRequired,
        y: PropTypes.number.isRequired,
    };
    var WrappedShape = React.forwardRef(function (_a, forwardedRef) {
        var 
        // props extracted here are not passed to child
        _b = _a.constrainMove, 
        // props extracted here are not passed to child
        constrainMove = _b === void 0 ? defaultConstrainMove : _b, _c = _a.constrainResize, constrainResize = _c === void 0 ? defaultConstrainResize : _c, _d = _a.isInternalComponent, isInternalComponent = _d === void 0 ? false : _d, _e = _a.keyboardTransformMultiplier, keyboardTransformMultiplier = _e === void 0 ? 1 : _e, _f = _a.onBlur, onBlur = _f === void 0 ? function () { } : _f, _g = _a.onChange, onChange = _g === void 0 ? function () { } : _g, _h = _a.onDelete, onDelete = _h === void 0 ? function () { } : _h, _j = _a.onFocus, onFocus = _j === void 0 ? function () { } : _j, _k = _a.onIntermediateChange, onIntermediateChange = _k === void 0 ? function () { } : _k, _l = _a.onKeyDown, onKeyDown = _l === void 0 ? function () { } : _l, _m = _a.ResizeHandleComponent, ResizeHandleComponent = _m === void 0 ? DefaultResizeHandleComponent : _m, _o = _a.wrapperProps, wrapperProps = _o === void 0 ? {} : _o, otherMainProps = __rest(_a, ["constrainMove", "constrainResize", "isInternalComponent", "keyboardTransformMultiplier", "onBlur", "onChange", "onDelete", "onFocus", "onIntermediateChange", "onKeyDown", "ResizeHandleComponent", "wrapperProps"]);
        var _p = useState(false), nativeActive = _p[0], setNativeActive = _p[1];
        var props = __assign(__assign({ disabled: false, isInSelectionGroup: false }, otherMainProps), { active: otherMainProps.active !== undefined
                ? otherMainProps.active
                : nativeActive, extraShapeProps: otherMainProps.extraShapeProps || {} });
        var 
        // props extracted here are still passed to the child
        active = props.active, disabled = props.disabled, isInSelectionGroup = props.isInSelectionGroup, shapeId = props.shapeId, height = props.height, width = props.width, x = props.x, y = props.y;
        var _q = useRootContext(), _r = _q.dimensions, scale = _r.scale, vectorHeight = _r.vectorHeight, vectorWidth = _r.vectorWidth, coordinateGetterRef = _q.coordinateGetterRef, eventEmitter = _q.eventEmitter;
        var wrapperElRef = useRef(null);
        var _s = useState(defaultDragState), _t = _s[0], isMouseDown = _t.isMouseDown, dragStartCoordinates = _t.dragStartCoordinates, dragCurrentCoordinates = _t.dragCurrentCoordinates, dragInnerOffset = _t.dragInnerOffset, dragLock = _t.dragLock, isDragToMove = _t.isDragToMove, setDragState = _s[1];
        useCancelModeOnEscapeKey(isMouseDown, function () {
            return setDragState(defaultDragState);
        });
        var forceFocusCb = useCallback(function () {
            // Force focus if it's not already focused
            if (!nativeActive) {
                forceFocus(wrapperElRef.current);
            }
        }, [nativeActive, wrapperElRef]);
        var getSelectionChildUpdatedRect = useCallback(createSelectionChildRectConstrainedGetter({ x: x, y: y, height: height, width: width }, constrainMove, constrainResize, vectorHeight, vectorWidth), [
            x,
            y,
            width,
            height,
            constrainMove,
            constrainResize,
            vectorWidth,
            vectorHeight,
        ]);
        var shapeActions = useShapeActions(forwardedRef, props, forceFocusCb, getSelectionChildUpdatedRect, setDragState);
        useNotifyRoot(eventEmitter, height, width, x, y, shapeId, isInternalComponent, shapeActions);
        var sides = !isMouseDown
            ? {
                left: x,
                right: x + width,
                top: y,
                bottom: y + height,
            }
            : {
                left: Math.min(dragStartCoordinates.x, dragCurrentCoordinates.x),
                right: Math.max(dragStartCoordinates.x, dragCurrentCoordinates.x),
                top: Math.min(dragStartCoordinates.y, dragCurrentCoordinates.y),
                bottom: Math.max(dragStartCoordinates.y, dragCurrentCoordinates.y),
            };
        var currentWidth = sides.right - sides.left;
        var currentHeight = sides.bottom - sides.top;
        var requestMouseHandler = useMouseHandlerRef(props, constrainMove, constrainResize, coordinateGetterRef, dragCurrentCoordinates, dragInnerOffset, dragLock, dragStartCoordinates, eventEmitter, isDragToMove, isMouseDown, onChange, onIntermediateChange, setDragState, vectorHeight, vectorWidth);
        // Generate drag handles
        var handles = getHandles(ResizeHandleComponent, sides, scale, active, nativeActive, isInSelectionGroup, coordinateGetterRef, requestMouseHandler, setDragState, isMouseDown);
        var shapeOnKeyDown = useOnKeyDown(props, constrainMove, constrainResize, height, keyboardTransformMultiplier, onChange, onDelete, onKeyDown, vectorHeight, vectorWidth, width, x, y);
        var gotFocusAfterClickRef = useRef(true);
        return (React.createElement("g", __assign({ "data-shape-id": shapeId, className: "rse-shape-wrapper", transform: "translate(" + sides.left + "," + sides.top + ")", style: __assign({ cursor: 'move', outline: 'none' }, (disabled ? { pointerEvents: 'none' } : {})), ref: wrapperElRef, focusable: !disabled ? 'true' : undefined, tabIndex: !disabled ? 0 : undefined, onFocus: function (event) {
                gotFocusAfterClickRef.current = true;
                eventEmitter.emit(EventType.ChildFocus, shapeId, isInternalComponent);
                setNativeActive(true);
                // Call user-defined focus handler
                onFocus(event, props);
            }, onBlur: function (event) {
                setNativeActive(false);
                onBlur(event, props);
            }, onMouseUp: function () {
                // Focusing support for Safari
                // Safari (12) does not currently allow focusing via mouse events,
                // even on elements with tabIndex="0" (tabbing with the keyboard
                // does work, however). This logic waits to see if focus was called
                // following a click, and forces the focused state if necessary.
                if (!gotFocusAfterClickRef.current) {
                    shapeActions.forceFocus();
                }
            }, onMouseDown: function (event) {
                // Ignore anything but left clicks
                if (event.buttons !== 1)
                    return;
                event.stopPropagation();
                if (event.shiftKey) {
                    eventEmitter.emit(EventType.ChildToggleSelection, shapeId, isInternalComponent, event);
                    // Prevent default to keep this from triggering blur/focus events
                    // on the elements involved, which would otherwise cause a wave
                    // of event listener callbacks that are not needed.
                    event.preventDefault();
                    return;
                }
                gotFocusAfterClickRef.current = false;
                var _a = coordinateGetterRef.current(event), planeX = _a.x, planeY = _a.y;
                requestMouseHandler();
                setDragState(function (prevState) { return (__assign(__assign({}, prevState), { isMouseDown: true, dragCurrentCoordinates: { x: x, y: y }, dragStartCoordinates: {
                        x: x + currentWidth,
                        y: y + currentHeight,
                    }, dragInnerOffset: {
                        x: planeX - x,
                        y: planeY - y,
                    }, isDragToMove: true })); });
            }, onKeyDown: shapeOnKeyDown }, wrapperProps),
            React.createElement(WrappedComponent, __assign({ isBeingChanged: isMouseDown, nativeActive: nativeActive, scale: scale }, props, { width: currentWidth, height: currentHeight })),
            !disabled && handles));
    });
    WrappedShape.propTypes = propTypes;
    WrappedShape.displayName = "wrapShape(" + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ")";
    return React.memo(WrappedShape);
}

var useImageLoader = function (imageSrc, onLoad) {
    var _a = useState({
        naturalHeight: 0,
        naturalWidth: 0,
    }), _b = _a[0], naturalHeight = _b.naturalHeight, naturalWidth = _b.naturalWidth, setDimensions = _a[1];
    // Use a ref so it only re-runs the image load effect when the source changes
    var onLoadRef = useRef(onLoad);
    useEffect(function () {
        var didCancel = false;
        // Load the background image in memory to measure its dimensions
        var memoryImage = new Image();
        memoryImage.onload = function () {
            if (didCancel) {
                return;
            }
            setDimensions({
                naturalWidth: memoryImage.naturalWidth,
                naturalHeight: memoryImage.naturalHeight,
            });
            onLoadRef.current({
                naturalWidth: memoryImage.naturalWidth,
                naturalHeight: memoryImage.naturalHeight,
            });
        };
        memoryImage.src = imageSrc;
        return function () {
            didCancel = true;
        };
    }, [imageSrc, onLoadRef]);
    return { naturalHeight: naturalHeight, naturalWidth: naturalWidth };
};
var propTypes$2 = {
    onLoad: PropTypes.func,
    src: PropTypes.string.isRequired,
};
var ImageLayer = function (_a) {
    var _b = _a.onLoad, onLoad = _b === void 0 ? function () { } : _b, src = _a.src, otherProps = __rest(_a, ["onLoad", "src"]);
    var _c = useImageLoader(src, onLoad), naturalHeight = _c.naturalHeight, naturalWidth = _c.naturalWidth;
    return (React.createElement("image", __assign({ href: src, width: naturalWidth, height: naturalHeight }, otherProps)));
};
ImageLayer.propTypes = propTypes$2;

var DefaultDrawPreviewComponent = wrapShape(function (_a) {
    var height = _a.height, width = _a.width;
    return (React.createElement("rect", { fill: "rgba(0,0,255,0.5)", height: height, width: width }));
});

var defaultPoint = { x: 0, y: 0 };
var defaultDragState$1 = {
    dragStartCoordinates: defaultPoint,
    dragCurrentCoordinates: defaultPoint,
    isMouseDown: false,
};
var propTypes$3 = {
    constrainMove: PropTypes.func,
    constrainResize: PropTypes.func,
    DrawPreviewComponent: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.shape({}),
    ]),
    onAddShape: PropTypes.func.isRequired,
    onDraw: PropTypes.func,
    onDrawEnd: PropTypes.func,
    onDrawStart: PropTypes.func,
};
var noop = function () { };
var DrawLayer = function (_a) {
    var _b = _a.DrawPreviewComponent, DrawPreviewComponent = _b === void 0 ? DefaultDrawPreviewComponent : _b, _c = _a.constrainResize, constrainResize = _c === void 0 ? defaultConstrainResize : _c, _d = _a.constrainMove, constrainMove = _d === void 0 ? defaultConstrainMove : _d, onAddShape = _a.onAddShape, _e = _a.onDraw, onDraw = _e === void 0 ? noop : _e, _f = _a.onDrawEnd, onDrawEnd = _f === void 0 ? noop : _f, _g = _a.onDrawStart, onDrawStart = _g === void 0 ? noop : _g;
    var _h = useRootContext(), _j = _h.dimensions, scale = _j.scale, vectorHeight = _j.vectorHeight, vectorPaddingBottom = _j.vectorPaddingBottom, vectorPaddingLeft = _j.vectorPaddingLeft, vectorPaddingRight = _j.vectorPaddingRight, vectorPaddingTop = _j.vectorPaddingTop, vectorWidth = _j.vectorWidth, eventEmitter = _h.eventEmitter, coordinateGetterRef = _h.coordinateGetterRef;
    var _k = useState(defaultDragState$1), _l = _k[0], isMouseDown = _l.isMouseDown, dragStartCoordinates = _l.dragStartCoordinates, dragCurrentCoordinates = _l.dragCurrentCoordinates, setDragState = _k[1];
    var getCoordinatesFromEvent = function (event, isStartEvent) {
        if (isStartEvent === void 0) { isStartEvent = false; }
        var _a = coordinateGetterRef.current(event), rawX = _a.x, rawY = _a.y;
        if (isStartEvent) {
            var _b = constrainMove({
                originalX: rawX,
                originalY: rawY,
                x: rawX,
                y: rawY,
                width: 0,
                height: 0,
                vectorWidth: vectorWidth,
                vectorHeight: vectorHeight,
            }), x_1 = _b.x, y_1 = _b.y;
            return { x: x_1, y: y_1 };
        }
        var _c = constrainResize({
            originalMovingCorner: dragCurrentCoordinates,
            startCorner: dragStartCoordinates,
            movingCorner: { x: rawX, y: rawY },
            lockedDimension: null,
            vectorWidth: vectorWidth,
            vectorHeight: vectorHeight,
        }), x = _c.x, y = _c.y;
        return { x: x, y: y };
    };
    var endDragAndReset = function (canceled) {
        if (canceled === void 0) { canceled = false; }
        setDragState(defaultDragState$1);
        onDrawEnd({
            startCorner: dragStartCoordinates,
            movingCorner: dragCurrentCoordinates,
            canceled: canceled,
        });
    };
    var onMouseUp = function () {
        if (!isMouseDown) {
            return;
        }
        var newRect = getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates);
        endDragAndReset();
        if (dragStartCoordinates.x !== dragCurrentCoordinates.x &&
            dragStartCoordinates.y !== dragCurrentCoordinates.y) {
            onAddShape(newRect);
        }
    };
    var onMouseMove = function (event) {
        if (!isMouseDown) {
            return;
        }
        var currentCoordinates = getCoordinatesFromEvent(event);
        setDragState(function (prevDragState) { return (__assign(__assign({}, prevDragState), { dragCurrentCoordinates: currentCoordinates })); });
        onDraw({
            startCorner: dragStartCoordinates,
            movingCorner: currentCoordinates,
        });
    };
    var mouseHandlerRef = useUpdatingRef(function (event) {
        if (event.type === 'mousemove') {
            onMouseMove(event);
        }
        else if (event.type === 'mouseup') {
            onMouseUp();
        }
    });
    useCancelModeOnEscapeKey(isMouseDown, function () { return endDragAndReset(true); });
    var draggedRect = isMouseDown
        ? getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates)
        : null;
    return (React.createElement(React.Fragment, null,
        React.createElement("rect", { className: "rse-draw-layer", x: -vectorPaddingLeft, y: -vectorPaddingTop, width: vectorWidth + vectorPaddingLeft + vectorPaddingRight, height: vectorHeight + vectorPaddingTop + vectorPaddingBottom, fill: "transparent", onMouseDown: function (event) {
                // Ignore anything but left clicks
                if (event.buttons !== 1)
                    return;
                var startCoordinates = getCoordinatesFromEvent(event, true);
                eventEmitter.overwriteAllListenersOfType(EventType.MouseEvent, mouseHandlerRef);
                setDragState({
                    dragStartCoordinates: startCoordinates,
                    dragCurrentCoordinates: startCoordinates,
                    isMouseDown: true,
                });
                onDrawStart({ startCorner: startCoordinates });
            } }),
        draggedRect && (React.createElement(DrawPreviewComponent, { height: draggedRect.height, disabled: true, isInternalComponent: true, scale: scale, shapeId: "rse-internal-draw-component", width: draggedRect.width, x: draggedRect.x, y: draggedRect.y }))));
};
DrawLayer.propTypes = propTypes$3;

var DefaultSelectionDrawComponent = wrapShape(function (_a) {
    var height = _a.height, width = _a.width;
    return (React.createElement("rect", { fill: "rgba(140,179,255,0.3)", height: height, width: width }));
});

var DefaultSelectionComponent = wrapShape(function (_a) {
    var height = _a.height, scale = _a.scale, width = _a.width;
    return (React.createElement("rect", { fill: "transparent", stroke: "rgba(140,179,255,1)", strokeWidth: 2 / scale, height: height, width: width }));
});

var defaultDragState$2 = {
    dragStartCoordinates: { x: 0, y: 0 },
    dragCurrentCoordinates: { x: 0, y: 0 },
    isMouseDown: false,
};
var SelectionContext = React.createContext(null);
var SELECTION_COMPONENT_SHAPE_ID = 'rse-internal-selection-component';
var getSelectionRect = function (childRects) {
    var selectionX = Math.min.apply(Math, childRects.map(function (c) { return c.x; }));
    var selectionY = Math.min.apply(Math, childRects.map(function (c) { return c.y; }));
    return {
        x: selectionX,
        y: selectionY,
        height: Math.max.apply(Math, childRects.map(function (c) { return c.y + c.height; })) - selectionY,
        width: Math.max.apply(Math, childRects.map(function (c) { return c.x + c.width; })) - selectionX,
    };
};
var useMouseHandlerRef$1 = function (isMouseDown, dragStartCoordinates, dragCurrentCoordinates, prevSelectedShapeIds, setDragState, coordinateGetterRef, selectionElRef, onSelectionChange, wrappedShapeActionRefsRef, selectionIsLargeEnough) {
    var onMouseUp = function () {
        if (!isMouseDown)
            return;
        if (!selectionIsLargeEnough()) {
            setDragState(defaultDragState$2);
            return;
        }
        var selectRect = getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates);
        var justSelectedShapeIds = Object.keys(wrappedShapeActionRefsRef.current).filter(function (shapeId) {
            var _a = wrappedShapeActionRefsRef.current[shapeId].current.props, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
            return (x + width > selectRect.x &&
                x < selectRect.x + selectRect.width &&
                y + height > selectRect.y &&
                y < selectRect.y + selectRect.height);
        });
        // Add to the selection anything that was newly selected and not present
        // in the existing selection, and remove from the selection anything that
        // was newly selected and already present in the existing selection.
        // Basically, we're toggling the selection state of the newly selected shapes
        var nextSelectedShapeIds = getNonIntersectingElements(justSelectedShapeIds, prevSelectedShapeIds);
        setDragState(defaultDragState$2);
        onSelectionChange(nextSelectedShapeIds);
        if (nextSelectedShapeIds.length >= 2 && selectionElRef.current) {
            // Focus on the group selection rect when it is first drawn
            selectionElRef.current.forceFocus();
        }
        else if (nextSelectedShapeIds.length === 1) {
            // In the event that a single shape is selected, give native focus to it as well
            wrappedShapeActionRefsRef.current[nextSelectedShapeIds[0]].current.forceFocus();
        }
    };
    var onMouseMove = function (event) {
        if (!isMouseDown)
            return;
        setDragState(function (dragState) { return (__assign(__assign({}, dragState), { dragCurrentCoordinates: coordinateGetterRef.current(event) })); });
    };
    var mouseHandlerRef = useUpdatingRef(function (event) {
        if (event.type === 'mousemove') {
            onMouseMove(event);
        }
        else if (event.type === 'mouseup') {
            onMouseUp();
        }
    });
    return mouseHandlerRef;
};
var useChildAddDeleteHandler$1 = function (eventEmitter, onSelectionChange, selectedShapeIds, selectionElRef, wrappedShapeActionRefsRef) {
    var selectedChildrenDidChangeRef = useRef(false);
    var forceUpdate = useForceUpdate();
    useLayoutEffect(function () {
        if (selectedChildrenDidChangeRef.current) {
            selectedChildrenDidChangeRef.current = false;
            // Only force update if there is a selection.
            // Otherwise, no change
            if (selectedShapeIds.length >= 2) {
                forceUpdate();
            }
        }
    });
    var onChildRectChanged = function (shapeId, isInternalComponent) {
        if (isInternalComponent)
            return;
        if (!selectedChildrenDidChangeRef.current &&
            selectedShapeIds.indexOf(shapeId) >= 0) {
            selectedChildrenDidChangeRef.current = true;
        }
    };
    var onShapeMountedOrUnmounted = function (shapeActionsRef, didMount) {
        var shapeId = shapeActionsRef.current.props.shapeId;
        if (!selectedChildrenDidChangeRef.current &&
            selectedShapeIds.indexOf(shapeId) >= 0) {
            selectedChildrenDidChangeRef.current = true;
        }
        if (didMount) {
            // eslint-disable-next-line no-param-reassign
            wrappedShapeActionRefsRef.current[shapeId] = shapeActionsRef;
        }
        else {
            // eslint-disable-next-line no-param-reassign
            delete wrappedShapeActionRefsRef.current[shapeId];
        }
    };
    var onChildToggleSelection = function (clickedShapeId, isInternalComponent, event) {
        var isClickingSelection = clickedShapeId === SELECTION_COMPONENT_SHAPE_ID;
        if (isInternalComponent && !isClickingSelection)
            return;
        var targetShapeId = clickedShapeId;
        // When trying to click shapes behind the selection rectangle, the
        // selection rectangle absorbs the mouseDown event, so we have to
        // use the position of the click to retrieve the element under the mouse.
        if (isClickingSelection) {
            var elementsUnderMouse = getElementsFromPoint(event.clientX, event.clientY);
            // Only the child elements (e.g., <rect>) of the wrapShape <g> tags
            // get picked up by elementsFromPoint, so here we aim to access the
            // <g> tags (which contain the shapeId) by getting the parentNode
            // of each element found
            for (var i = 0; i < elementsUnderMouse.length; i += 1) {
                var parentNode = elementsUnderMouse[i].parentNode;
                if (!parentNode || !(parentNode instanceof SVGGElement)) {
                    // eslint-disable-next-line no-continue
                    continue;
                }
                // IE11-compatible way to get dataset info from SVG elements
                var shapeId = void 0;
                if (parentNode.dataset) {
                    (shapeId = parentNode.dataset.shapeId);
                }
                else if (typeof parentNode.getAttribute === 'function') {
                    shapeId = parentNode.getAttribute('data-shape-id');
                }
                if (typeof shapeId !== 'string' ||
                    shapeId === SELECTION_COMPONENT_SHAPE_ID) {
                    // eslint-disable-next-line no-continue
                    continue;
                }
                targetShapeId = shapeId;
                break;
            }
        }
        var isAdd = selectedShapeIds.indexOf(targetShapeId) < 0;
        if (isAdd) {
            var nextSelectedShapeIds = __spreadArrays(selectedShapeIds, [targetShapeId]);
            onSelectionChange(nextSelectedShapeIds);
            if (nextSelectedShapeIds.length >= 2) {
                // Focus on the group selection rect when it is drawn
                if (selectionElRef.current) {
                    selectionElRef.current.forceFocus();
                }
                else {
                    setTimeout(function () {
                        if (selectionElRef.current) {
                            selectionElRef.current.forceFocus();
                        }
                    });
                }
            }
        }
        else if (selectedShapeIds.length >= 2) {
            // Only deselect when it is a group selection
            onSelectionChange(selectedShapeIds.filter(function (id) { return id !== targetShapeId; }));
        }
    };
    var onChildFocus = function (shapeId, isInternalComponent) {
        if (isInternalComponent)
            return;
        if (
        // We don't want to focus on the shape if it's already
        // the only focused shape
        selectedShapeIds.length !== 1 ||
            selectedShapeIds[0] !== shapeId) {
            onSelectionChange([shapeId]);
        }
    };
    useAdditionalListener(eventEmitter, EventType.MountedOrUnmounted, onShapeMountedOrUnmounted);
    useAdditionalListener(eventEmitter, EventType.ChildToggleSelection, onChildToggleSelection);
    useAdditionalListener(eventEmitter, EventType.ChildRectChanged, onChildRectChanged);
    useAdditionalListener(eventEmitter, EventType.ChildFocus, onChildFocus);
};
var propTypes$4 = {
    children: PropTypes.node,
    keyboardTransformMultiplier: PropTypes.number,
    minimumDistanceForSelection: PropTypes.number,
    onChange: PropTypes.func,
    onDelete: PropTypes.func,
    onSelectionChange: PropTypes.func.isRequired,
    selectedShapeIds: PropTypes.arrayOf(PropTypes.string.isRequired).isRequired,
    SelectionComponent: PropTypes.elementType,
    selectionComponentProps: PropTypes.shape({}),
    SelectionDrawComponent: PropTypes.elementType,
};
var SelectionLayer = function (_a) {
    var _b = _a.children, children = _b === void 0 ? null : _b, _c = _a.keyboardTransformMultiplier, keyboardTransformMultiplier = _c === void 0 ? 1 : _c, _d = _a.minimumDistanceForSelection, minimumDistanceForSelection = _d === void 0 ? 15 : _d, _e = _a.onChange, onChange = _e === void 0 ? function () { } : _e, _f = _a.onDelete, onDelete = _f === void 0 ? function () { } : _f, onSelectionChange = _a.onSelectionChange, selectedShapeIds = _a.selectedShapeIds, _g = _a.SelectionComponent, SelectionComponent = _g === void 0 ? DefaultSelectionComponent : _g, _h = _a.selectionComponentProps, selectionComponentProps = _h === void 0 ? {} : _h, _j = _a.SelectionDrawComponent, SelectionDrawComponent = _j === void 0 ? DefaultSelectionDrawComponent : _j;
    var _k = useState(defaultDragState$2), _l = _k[0], isMouseDown = _l.isMouseDown, dragStartCoordinates = _l.dragStartCoordinates, dragCurrentCoordinates = _l.dragCurrentCoordinates, setDragState = _k[1];
    useCancelModeOnEscapeKey(isMouseDown, function () { return setDragState(defaultDragState$2); });
    var selectionIsLargeEnough = function () {
        var selectionRect = getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates);
        return (selectionRect.width >= minimumDistanceForSelection ||
            selectionRect.height >= minimumDistanceForSelection);
    };
    var _m = useRootContext(), _o = _m.dimensions, vectorHeight = _o.vectorHeight, vectorPaddingBottom = _o.vectorPaddingBottom, vectorPaddingLeft = _o.vectorPaddingLeft, vectorPaddingRight = _o.vectorPaddingRight, vectorPaddingTop = _o.vectorPaddingTop, vectorWidth = _o.vectorWidth, eventEmitter = _m.eventEmitter, coordinateGetterRef = _m.coordinateGetterRef;
    var selectionElRef = useRef(null);
    var wrappedShapeActionRefsRef = useRef({});
    useChildAddDeleteHandler$1(eventEmitter, onSelectionChange, selectedShapeIds, selectionElRef, wrappedShapeActionRefsRef);
    var mouseHandlerRef = useMouseHandlerRef$1(isMouseDown, dragStartCoordinates, dragCurrentCoordinates, selectedShapeIds, setDragState, coordinateGetterRef, selectionElRef, onSelectionChange, wrappedShapeActionRefsRef, selectionIsLargeEnough);
    var selectedShapeActionRefs = selectedShapeIds
        .map(function (shapeId) { return wrappedShapeActionRefsRef.current[shapeId]; })
        .filter(Boolean);
    var simulatedTransformRef = useRef(0);
    var selectionDrawComponent = null;
    if (isMouseDown) {
        if (selectionIsLargeEnough()) {
            var selectionRect = getRectFromCornerCoordinates(dragStartCoordinates, dragCurrentCoordinates);
            selectionDrawComponent = (React.createElement(SelectionDrawComponent, { shapeId: "rse-internal-selection-draw-component", disabled: true, height: selectionRect.height, isInternalComponent: true, width: selectionRect.width, x: selectionRect.x, y: selectionRect.y }));
        }
    }
    var selectionComponent = null;
    if (selectedShapeActionRefs.length >= 2) {
        var selectionRect_1 = getSelectionRect(selectedShapeActionRefs.map(function (s) { return s.current.props; }));
        selectionComponent = (React.createElement(SelectionComponent, __assign({ keyboardTransformMultiplier: keyboardTransformMultiplier }, selectionComponentProps, { shapeId: SELECTION_COMPONENT_SHAPE_ID, isInternalComponent: true, ref: selectionElRef, onIntermediateChange: function (intermediateRect) {
                cancelAnimationFrame(simulatedTransformRef.current);
                simulatedTransformRef.current = requestAnimationFrame(function () {
                    selectedShapeActionRefs.forEach(function (shapeActionRef) {
                        var tempRect = shapeActionRef.current.getSelectionChildUpdatedRect(selectionRect_1, intermediateRect);
                        shapeActionRef.current.simulateTransform(tempRect);
                    });
                });
            }, onDelete: function (event) {
                onDelete(event, selectedShapeActionRefs.map(function (shapeActionRef) { return shapeActionRef.current.props; }));
            }, onChange: function (nextSelectionRect) {
                var nextRects = selectedShapeActionRefs.map(function (shapeActionRef) {
                    return shapeActionRef.current.getSelectionChildUpdatedRect(selectionRect_1, nextSelectionRect);
                });
                // Restore the shapes back to their original positions
                cancelAnimationFrame(simulatedTransformRef.current);
                selectedShapeActionRefs.forEach(function (s) {
                    s.current.simulateTransform(null);
                });
                onChange(nextRects, selectedShapeActionRefs.map(function (s) { return s.current.props; }));
            }, height: selectionRect_1.height, width: selectionRect_1.width, x: selectionRect_1.x, y: selectionRect_1.y })));
    }
    return (React.createElement("g", { onMouseDown: function (event) {
            // Ignore anything but left clicks
            if (event.buttons !== 1)
                return;
            // Clear the selection if shift was not pressed
            if (!event.shiftKey && selectedShapeIds.length > 0) {
                onSelectionChange([]);
            }
        } },
        React.createElement("rect", { className: "rse-selection-layer", x: -vectorPaddingLeft, y: -vectorPaddingTop, width: vectorWidth + vectorPaddingLeft + vectorPaddingRight, height: vectorHeight + vectorPaddingTop + vectorPaddingBottom, fill: "transparent", onMouseDown: function (event) {
                // Ignore anything but left clicks
                if (event.buttons !== 1)
                    return;
                var startCoordinates = coordinateGetterRef.current(event);
                eventEmitter.overwriteAllListenersOfType(EventType.MouseEvent, mouseHandlerRef);
                setDragState({
                    dragStartCoordinates: startCoordinates,
                    dragCurrentCoordinates: startCoordinates,
                    isMouseDown: true,
                });
                // Clear the selection if shift was not pressed
                if (!event.shiftKey && selectedShapeIds.length > 0) {
                    onSelectionChange([]);
                }
            } }),
        children,
        selectionComponent,
        selectionDrawComponent));
};
SelectionLayer.propTypes = propTypes$4;

export { DrawLayer, ImageLayer, SelectionLayer, ShapeEditor, wrapShape };
//# sourceMappingURL=index.esm.js.map
